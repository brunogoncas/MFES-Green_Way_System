class Client
types
-- TODO Define types here
values
-- TODO Define values here
instance variables
	private name : seq of char;
	private cc : nat;
	private nif : nat;
	private nib : nat;
	private debt: real;
	private devices: set of Device;
	
	inv not exists c1, c2 in set devices &
		c1 <> c2 and c1.GetPlate() = c2.GetPlate();
	
operations
	public Client: seq of char * nat * nat * nat * set of Device ==> Client
	
	Client(cName, cCC, cNif, cNib, cDevices) == (name := cName; cc := cCC; nif := cNif; nib := cNib; devices := cDevices; debt := 0; return self)
	pre cName <> "" and cDevices <> {} /* missing pre conditions for the rest */
	post name = cName and cc = cCC and nif = cNif and nib = cNib and devices = cDevices;
	
	
	public addToDebt: real ==> ()
		addToDebt(value) == debt := debt + value;
		
	public payDebt: real ==> ()
		payDebt(value) == debt := debt - value
		pre value > 0 and debt >= 0
		post value <= debt and debt >= 0;
		
	public addDevice : Device  ==> ()
		addDevice(cDevice) == devices := ({cDevice} union devices)
		post devices = ({cDevice} union devices~);
		
	public pure getName: () ==> seq of char
		getName() == return name;
	
	public pure getCc: () ==> real
		getCc() == return cc;
		
	public pure getNif: () ==> real
		getNif() == return nif;
	
	public pure getNib: () ==> real
		getNib() == return nib;
	
	public pure getDebt: () ==> real
		getDebt() == return debt;
		
	public pure getDevices: () ==> set of Device
		getDevices() == return devices;


functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Client